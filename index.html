<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹¤ì‹œê°„ ìì„¸ ì¶”ì • (ê°ë„ ì¡°ì ˆ + ì˜¤ë””ì˜¤ í”¼ë“œë°±)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        h1 {
            color: #333;
        }
        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* ìš”ì†Œ ê°„ ê°„ê²© */
        }
        #liveView {
            position: relative;
            width: 640px;
            height: 480px;
            border: 1px solid #ccc;
            background-color: #000;
        }
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            visibility: hidden;
        }
        #outputCanvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1.2em; color: white; background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px; border-radius: 5px; z-index: 10;
        }
        .warning {
            background-color: #fff3cd; color: #856404; padding: 15px;
            border: 1px solid #ffeeba; border-radius: 5px;
            max-width: 640px; text-align: center;
        }
        .pose-text {
            position: absolute; top: 10px; left: 10px;
            background-color: rgba(0, 0, 0, 0.6); color: white;
            padding: 8px 12px; font-size: 1.5em; border-radius: 5px; z-index: 5;
        }
        /* ì»¨íŠ¸ë¡¤ ì˜ì—­ ìŠ¤íƒ€ì¼ */
        #controls {
            display: flex;
            flex-direction: column; /* ì„¸ë¡œ ë°°ì¹˜ */
            align-items: stretch; /* í•­ëª© ë„ˆë¹„ ë§ì¶¤ */
            gap: 10px; /* ì»¨íŠ¸ë¡¤ ê°„ ê°„ê²© */
            background-color: #e9e9e9;
            padding: 15px;
            border-radius: 8px;
            width: 640px; /* ë¹„ë””ì˜¤ ë„ˆë¹„ì™€ ë§ì¶¤ */
            box-sizing: border-box; /* íŒ¨ë”© í¬í•¨ ë„ˆë¹„ ê³„ì‚° */
        }
        .control-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-item label {
            min-width: 130px; /* ë ˆì´ë¸” ë„ˆë¹„ ê³ ì • */
            text-align: right;
        }
        .control-item input[type="range"] {
            flex-grow: 1; /* ë‚¨ì€ ê³µê°„ ì°¨ì§€ */
        }
        .control-item span {
            min-width: 40px; /* ê°’ í‘œì‹œ ë„ˆë¹„ ê³ ì • */
            text-align: right;
            font-weight: bold;
        }
        /* ì˜¤ë””ì˜¤ ë²„íŠ¼ */
        #audioButton {
            padding: 10px 15px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50; /* Green */
            color: white;
            transition: background-color 0.3s;
        }
         #audioButton:hover {
            background-color: #45a049;
        }
        #audioButton.playing {
            background-color: #f44336; /* Red */
        }
         #audioButton.playing:hover {
            background-color: #da190b;
        }
    </style>
    <!-- ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ (ë™ì¼) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
</head>
<body>
    <h1>ì‹¤ì‹œê°„ ìì„¸ ì¶”ì • (ê°ë„ ì¡°ì ˆ + ì˜¤ë””ì˜¤ í”¼ë“œë°±)</h1>

    <div class="warning">
        <strong>ì£¼ì˜:</strong> ì‚¬ëŒ ìì„¸ ì¶”ì • ëª¨ë¸(MoveNet) ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤.<br>
        ìŠ¬ë¼ì´ë”ë¡œ 'ì•‰ê¸°'/'ì„œê¸°' íŒë³„ ê°ë„ë¥¼ ì¡°ì ˆí•˜ê³ , ì˜¤ë””ì˜¤ ë²„íŠ¼ìœ¼ë¡œ ì†Œë¦¬ í”¼ë“œë°±ì„ ì¼œê±°ë‚˜ ëŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>
        ì›¹ìº  ë° ì˜¤ë””ì˜¤ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.
    </div>

    <div id="container">
        <div id="liveView">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="outputCanvas"></canvas>
            <div id="loading">ëª¨ë¸ ë° ì›¹ìº  ë¡œë”© ì¤‘...</div>
            <div id="poseResult" class="pose-text" style="display: none;"></div>
        </div>

        <!-- ì»¨íŠ¸ë¡¤ ì˜ì—­ -->
        <div id="controls">
            <div class="control-item">
                <label for="sittingThreshold">ì•‰ê¸° íŒë³„ ê°ë„ (<):</label>
                <input type="range" id="sittingThreshold" min="90" max="170" value="140">
                <span id="sittingThresholdValue">140</span>Â°
            </div>
            <div class="control-item">
                <label for="standingThreshold">ì„œê¸° íŒë³„ ê°ë„ (>):</label>
                <input type="range" id="standingThreshold" min="100" max="179" value="160">
                <span id="standingThresholdValue">160</span>Â°
            </div>
             <div class="control-item">
                 <button id="audioButton">ì˜¤ë””ì˜¤ í”¼ë“œë°± ì‹œì‘</button>
                 <span>(Sitting: ë‚®ìŒ, Standing: ë†’ìŒ)</span>
             </div>
        </div>
    </div>

    <script>
        // --- DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸° ---
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('outputCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingElement = document.getElementById('loading');
        const poseResultElement = document.getElementById('poseResult');
        const sittingThresholdSlider = document.getElementById('sittingThreshold');
        const sittingThresholdValueSpan = document.getElementById('sittingThresholdValue');
        const standingThresholdSlider = document.getElementById('standingThreshold');
        const standingThresholdValueSpan = document.getElementById('standingThresholdValue');
        const audioButton = document.getElementById('audioButton');

        // --- ì „ì—­ ë³€ìˆ˜ ---
        let detector;
        let rafId;
        let sittingThresholdAngle = 140; // ê¸°ë³¸ê°’
        let standingThresholdAngle = 160; // ê¸°ë³¸ê°’

        // --- Web Audio API ë³€ìˆ˜ ---
        let audioContext;
        let oscillator;
        let gainNode;
        let isAudioPlaying = false;
        const SITTING_FREQ = 261.63; // C4 (ë‚®ì€ ë„)
        const STANDING_FREQ = 523.25; // C5 (ë†’ì€ ë„)
        const VOLUME = 0.1; // ì‚¬ì¸íŒŒ ë³¼ë¥¨ (ë„ˆë¬´ í¬ì§€ ì•Šê²Œ)

        // --- ëª¨ë¸ ë° í‚¤í¬ì¸íŠ¸ ì„¤ì • (ë™ì¼) ---
        const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing: true };
        const KEYPOINTS = { /* ... ì´ì „ ì½”ë“œì™€ ë™ì¼ ... */
             NOSE: 0, LEFT_EYE: 1, RIGHT_EYE: 2, LEFT_EAR: 3, RIGHT_EAR: 4,
            LEFT_SHOULDER: 5, RIGHT_SHOULDER: 6, LEFT_ELBOW: 7, RIGHT_ELBOW: 8,
            LEFT_WRIST: 9, RIGHT_WRIST: 10, LEFT_HIP: 11, RIGHT_HIP: 12,
            LEFT_KNEE: 13, RIGHT_KNEE: 14, LEFT_ANKLE: 15, RIGHT_ANKLE: 16
        };
        const connections = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);

        // --- í•¨ìˆ˜ë“¤ ---

        // ì›¹ìº  ì„¤ì • (ë™ì¼)
        async function setupWebcam() { /* ... ì´ì „ ì½”ë“œì™€ ë™ì¼ ... */
            return new Promise((resolve, reject) => {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        videoElement.srcObject = stream;
                        videoElement.addEventListener('loadeddata', () => {
                            canvasElement.width = videoElement.videoWidth;
                            canvasElement.height = videoElement.videoHeight;
                            resolve();
                        });
                    })
                    .catch(err => {
                        console.error("ì›¹ìº  ì ‘ê·¼ ì˜¤ë¥˜:", err);
                        loadingElement.innerText = "ì›¹ìº  ì ‘ê·¼ ì‹¤íŒ¨. ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.";
                        reject(err);
                    });
            });
        }

        // ëª¨ë¸ ë¡œë“œ (ë™ì¼)
        async function loadModel() { /* ... ì´ì „ ì½”ë“œì™€ ë™ì¼ ... */
             try {
                detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
                console.log("MoveNet ëª¨ë¸ ë¡œë“œ ì™„ë£Œ.");
            } catch (error) {
                console.error("ëª¨ë¸ ë¡œë“œ ì˜¤ë¥˜:", error);
                loadingElement.innerText = "ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨.";
                throw error;
            }
        }

        // í‚¤í¬ì¸íŠ¸/ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë¦¬ê¸° (ë™ì¼)
        function drawKeypoint(keypoint) { /* ... ì´ì „ ì½”ë“œì™€ ë™ì¼ ... */
             if (keypoint.score > 0.3) {
                const radius = 5;
                canvasCtx.beginPath();
                canvasCtx.arc(keypoint.x, keypoint.y, radius, 0, 2 * Math.PI);
                canvasCtx.fillStyle = 'aqua';
                canvasCtx.fill();
            }
         }
        function drawSkeleton(keypoints) { /* ... ì´ì „ ì½”ë“œì™€ ë™ì¼ ... */
             canvasCtx.fillStyle = 'aqua';
            canvasCtx.strokeStyle = 'lime';
            canvasCtx.lineWidth = 2;
            keypoints.forEach(keypoint => drawKeypoint(keypoint));
            connections.forEach((pair) => {
                const [i, j] = pair;
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                if (kp1.score > 0.3 && kp2.score > 0.3) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(kp1.x, kp1.y);
                    canvasCtx.lineTo(kp2.x, kp2.y);
                    canvasCtx.stroke();
                }
            });
        }

        // ê°ë„ ê³„ì‚° (ë™ì¼)
        function calculateAngle(a, b, c) { /* ... ì´ì „ ì½”ë“œì™€ ë™ì¼ ... */
            const baX = a.x - b.x; const baY = a.y - b.y;
            const bcX = c.x - b.x; const bcY = c.y - b.y;
            const dotProduct = baX * bcX + baY * bcY;
            const magnitudeBA = Math.sqrt(baX * baX + baY * baY);
            const magnitudeBC = Math.sqrt(bcX * bcX + bcY * bcY);
            if (magnitudeBA === 0 || magnitudeBC === 0) return null;
            const cosTheta = dotProduct / (magnitudeBA * magnitudeBC);
            const clampedCosTheta = Math.max(-1.0, Math.min(1.0, cosTheta));
            return Math.acos(clampedCosTheta) * (180 / Math.PI);
         }

        // ìì„¸ ë¶„ë¥˜ í•¨ìˆ˜ (ì„ê³„ê°’ ë³€ìˆ˜ ì‚¬ìš©)
        function classifyPose(keypoints) {
            const confidenceThreshold = 0.3;
            const requiredKeypoints = [
                KEYPOINTS.LEFT_SHOULDER, KEYPOINTS.RIGHT_SHOULDER, KEYPOINTS.LEFT_HIP, KEYPOINTS.RIGHT_HIP,
                KEYPOINTS.LEFT_KNEE, KEYPOINTS.RIGHT_KNEE, KEYPOINTS.LEFT_ANKLE, KEYPOINTS.RIGHT_ANKLE
            ];
            if (requiredKeypoints.some(idx => keypoints[idx].score < confidenceThreshold)) {
                //console.log("í•„ìˆ˜ í‚¤í¬ì¸íŠ¸ ì‹ ë¢°ë„ ë¶€ì¡±");
                return null;
            }

            const leftShoulder = keypoints[KEYPOINTS.LEFT_SHOULDER];
            const rightShoulder = keypoints[KEYPOINTS.RIGHT_SHOULDER];
            const leftHip = keypoints[KEYPOINTS.LEFT_HIP];
            const rightHip = keypoints[KEYPOINTS.RIGHT_HIP];
            const leftKnee = keypoints[KEYPOINTS.LEFT_KNEE];
            const rightKnee = keypoints[KEYPOINTS.RIGHT_KNEE];
            const leftAnkle = keypoints[KEYPOINTS.LEFT_ANKLE];
            const rightAnkle = keypoints[KEYPOINTS.RIGHT_ANKLE];

            const avgShoulderY = (leftShoulder.y + rightShoulder.y) / 2;
            const avgHipY = (leftHip.y + rightHip.y) / 2;
            const isUpright = avgShoulderY < (avgHipY - 50);

            if (isUpright) {
                const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
                const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
                let avgKneeAngle = null;

                if (leftKneeAngle !== null && rightKneeAngle !== null) {
                    avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;
                } else if (leftKneeAngle !== null) avgKneeAngle = leftKneeAngle;
                else if (rightKneeAngle !== null) avgKneeAngle = rightKneeAngle;

                if (avgKneeAngle !== null) {
                    // *** ì¡°ì ˆëœ ì„ê³„ê°’ ì‚¬ìš© ***
                    if (avgKneeAngle < sittingThresholdAngle) {
                        return "Sitting ğŸ§˜";
                    } else if (avgKneeAngle > standingThresholdAngle) {
                        return "StandingğŸ§";
                    }
                }
            }
            return null; // ìœ„ ì¡°ê±´ ì™¸ì—ëŠ” íŒë³„ ë¶ˆê°€
        }

        // --- Web Audio API ì„¤ì • í•¨ìˆ˜ ---
        function setupAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                oscillator = audioContext.createOscillator();
                gainNode = audioContext.createGain();

                oscillator.type = 'sine'; // ì‚¬ì¸íŒŒ
                oscillator.frequency.setValueAtTime(SITTING_FREQ, audioContext.currentTime); // ì´ˆê¸° ì£¼íŒŒìˆ˜ ì„¤ì •
                gainNode.gain.setValueAtTime(0, audioContext.currentTime); // ì´ˆê¸° ë³¼ë¥¨ 0 (ì†Œë¦¬ ì•ˆë‚¨)

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(); // ì˜¤ì‹¤ë ˆì´í„° ì‹œì‘ (ì£¼íŒŒìˆ˜/ë³¼ë¥¨ì€ ê³„ì† ì¡°ì ˆ ê°€ëŠ¥)
                console.log("Web Audio API ì´ˆê¸°í™” ì™„ë£Œ.");
            } catch (e) {
                console.error("Web Audio API ì´ˆê¸°í™” ì‹¤íŒ¨:", e);
                alert("ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì €ê°€ Web Audio APIë¥¼ ì§€ì›í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.");
            }
        }

        // --- ì˜¤ë””ì˜¤ ì œì–´ í•¨ìˆ˜ ---
        function controlAudio(pose) {
            if (!audioContext || !isAudioPlaying) { // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì—†ê±°ë‚˜, ì‚¬ìš©ìê°€ ì‹œì‘ ì•ˆí–ˆìœ¼ë©´ ì¤‘ì§€
                 if (gainNode) gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                return;
            }

            const now = audioContext.currentTime;
            if (pose === "Sitting ğŸ§˜") {
                oscillator.frequency.linearRampToValueAtTime(SITTING_FREQ, now + 0.1); // ë¶€ë“œëŸ½ê²Œ ì£¼íŒŒìˆ˜ ë³€ê²½
                gainNode.gain.linearRampToValueAtTime(VOLUME, now + 0.1); // ë¶€ë“œëŸ½ê²Œ ë³¼ë¥¨ ì¼œê¸°
            } else if (pose === "StandingğŸ§") {
                oscillator.frequency.linearRampToValueAtTime(STANDING_FREQ, now + 0.1);
                gainNode.gain.linearRampToValueAtTime(VOLUME, now + 0.1);
            } else {
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1); // ì†Œë¦¬ ë„ê¸°
            }
        }

        // --- ì‹¤ì‹œê°„ ê°ì§€ ë° ê·¸ë¦¬ê¸° ë£¨í”„ ---
        async function renderPrediction() {
            if (!detector || videoElement.readyState < 4) { // videoElement.readyState === 4 ëŒ€ì‹  < 4 ë¡œ í™•ì¸
                rafId = requestAnimationFrame(renderPrediction);
                return;
            }

            const poses = await detector.estimatePoses(videoElement, { flipHorizontal: false });

            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

            let currentPose = null;

            if (poses && poses.length > 0) {
                const keypoints = poses[0].keypoints;
                drawSkeleton(keypoints);
                currentPose = classifyPose(keypoints);
            }

            // ìì„¸ ê²°ê³¼ ì‹œê°í™”
            if (currentPose) {
                poseResultElement.innerText = currentPose;
                poseResultElement.style.display = 'block';
            } else {
                poseResultElement.style.display = 'none';
            }

            // ì˜¤ë””ì˜¤ í”¼ë“œë°± ì œì–´
            controlAudio(currentPose);

            rafId = requestAnimationFrame(renderPrediction);
        }

        // --- ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ---
        function setupSliders() {
            sittingThresholdSlider.addEventListener('input', (event) => {
                sittingThresholdAngle = parseInt(event.target.value);
                sittingThresholdValueSpan.textContent = sittingThresholdAngle;
                // ì„œê¸° ê°’ë³´ë‹¤ ì‘ë„ë¡ ê°•ì œ (ì˜µì…˜)
                if (sittingThresholdAngle >= standingThresholdAngle) {
                     standingThresholdAngle = sittingThresholdAngle + 1;
                     standingThresholdSlider.value = standingThresholdAngle;
                     standingThresholdValueSpan.textContent = standingThresholdAngle;
                }
            });

            standingThresholdSlider.addEventListener('input', (event) => {
                standingThresholdAngle = parseInt(event.target.value);
                standingThresholdValueSpan.textContent = standingThresholdAngle;
                 // ì•‰ê¸° ê°’ë³´ë‹¤ í¬ë„ë¡ ê°•ì œ (ì˜µì…˜)
                 if (standingThresholdAngle <= sittingThresholdAngle) {
                     sittingThresholdAngle = standingThresholdAngle - 1;
                     sittingThresholdSlider.value = sittingThresholdAngle;
                     sittingThresholdValueSpan.textContent = sittingThresholdAngle;
                 }
            });

             // ì´ˆê¸° ìŠ¬ë¼ì´ë” ê°’ ì„¤ì •
            sittingThresholdSlider.value = sittingThresholdAngle;
            sittingThresholdValueSpan.textContent = sittingThresholdAngle;
            standingThresholdSlider.value = standingThresholdAngle;
            standingThresholdValueSpan.textContent = standingThresholdAngle;
        }

        // --- ì˜¤ë””ì˜¤ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
        function setupAudioButton() {
             audioButton.addEventListener('click', () => {
                 if (!audioContext) { // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ê°€ ì•„ì§ ì—†ìœ¼ë©´ ìƒì„± ì‹œë„
                     setupAudio();
                     if (!audioContext) return; // ìƒì„± ì‹¤íŒ¨ ì‹œ ì¤‘ë‹¨
                 }

                 // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ìƒíƒœ í™•ì¸ ë° ì¬ê°œ (ì‚¬ìš©ì ì¸í„°ë™ì…˜ í›„ í•„ìš”í•  ìˆ˜ ìˆìŒ)
                 if (audioContext.state === 'suspended') {
                     audioContext.resume();
                 }

                 isAudioPlaying = !isAudioPlaying; // ì¬ìƒ ìƒíƒœ í† ê¸€

                 if (isAudioPlaying) {
                     audioButton.textContent = 'ì˜¤ë””ì˜¤ í”¼ë“œë°± ì¤‘ì§€';
                     audioButton.classList.add('playing');
                     // controlAudio í•¨ìˆ˜ê°€ renderPrediction ë£¨í”„ì—ì„œ í˜¸ì¶œë˜ë¯€ë¡œ ì—¬ê¸°ì„œ ë°”ë¡œ gainì„ ì„¤ì •í•  í•„ìš”ëŠ” ì—†ìŒ
                 } else {
                     audioButton.textContent = 'ì˜¤ë””ì˜¤ í”¼ë“œë°± ì‹œì‘';
                     audioButton.classList.remove('playing');
                     // ì¦‰ì‹œ ì†Œë¦¬ ë„ê¸°
                     if(gainNode) gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                 }
             });
        }


        // --- ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜ ---
        async function main() {
            try {
                await tf.setBackend('webgl');
                setupSliders(); // ìŠ¬ë¼ì´ë” ì„¤ì • ë¨¼ì €
                setupAudioButton(); // ì˜¤ë””ì˜¤ ë²„íŠ¼ ì„¤ì •
                // setupAudio(); // ì˜¤ë””ì˜¤ëŠ” ë²„íŠ¼ í´ë¦­ ì‹œ ì´ˆê¸°í™”í•˜ë„ë¡ ë³€ê²½
                await loadModel();
                await setupWebcam();

                loadingElement.style.display = 'none';
                videoElement.play();
                renderPrediction();

            } catch (error) {
                console.error("ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
                if (loadingElement.innerText.includes('ë¡œë”© ì¤‘')) {
                   loadingElement.innerText = "ì˜¤ë¥˜ ë°œìƒ. ì½˜ì†” í™•ì¸.";
                }
            }
        }

        // í”„ë¡œê·¸ë¨ ì‹œì‘
        main();

        // í˜ì´ì§€ ë²—ì–´ë‚  ë•Œ ì •ë¦¬
        window.addEventListener('beforeunload', () => {
            if (rafId) cancelAnimationFrame(rafId);
            if (detector) detector.dispose();
            if (videoElement.srcObject) videoElement.srcObject.getTracks().forEach(track => track.stop());
            // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì¢…ë£Œ
            if (audioContext) {
                oscillator.stop();
                audioContext.close();
            }
        });

    </script>
</body>
</html>
